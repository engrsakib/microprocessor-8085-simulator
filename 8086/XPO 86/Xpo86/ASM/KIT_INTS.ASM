;	TITLE	KIT_INTS-LIBRARY OF KIT INT CALLS
;AS PC OFFERS ROM BIOS OR DOS INT CALLS,KIT MONITOR TOO OFFERS INT CALLS(A0-BF)
;USEFUL FOR DEVELOPING YOUR APPLICATION PROGRAMES ON KIT BATTERY BACKUP RAM.
;INITIALY WHILE DEVELOPING  THE SOFTWARE ON PC USING MASM YOU WILL THEREFORE
;NEED THESE INTS (A0-BF) ON PC .THE FOLLOWING LISTING OF LIBRARY PROGRAMES
;PROVIDE YOU KIT MONITOR ENVIRONMENT ON PC IN THE FORM OF INT CALLS (A0 TO BF).
;DON`T EVER CALL DIRECTLY USING CALL INST.INCLUDE FOLLOWING PSEUDO INSTRUCTION
;IN YOUR PROGRAME JUST BEFORE  ENDS  STATEMENT--
;	INCLUDE KIT_INTS.ASM
;ALSO INCLUDE   CALL LDINPC     IN INITIALISATION PART OF YOUR APPLICATION 
;PROGRAME.THIS WILL LOAD ADDRS OF KIT INTS (A0-BF ONLY)IN PC RAM.ONCE YOU HAVE
;PROVEN YOYR SOFTWARE ON PC,THEN REPLACE 3 NOPS (90) IN PLACE OF CALL LDINPC
;AND ALSO REMOVE INCLUDE KIT_INTS.ASM STATEMENT.THE RESULTING .ASM FILE
;OF YOUR PROGRAME CAN BE CONVERTED TO .HEX USING SERIAL.BAT FILE,AND DOWNLOADED
;USING PCSERIAL.EXE INTO KIT.
	IF1
	INCLUDE  MAC.LIB		;TO SUIT PC/KIT
	INCLUDE  CRMAC.LIB		;CODE REPEATER MACRO
	ENDIF	
	INCLUDE EQUAT.LIB
LDINPC	PROC	
BEGCOM: JMP NEAR PTR RESET		;BEG COM FILE HERE  

INTXX	DW 0FFH DUP (0FFF0H,0F000H)	;ALL UNUSED INTS
INTA0 	DW	ISRA0,BASE		;A0-
      	DW	ISRA1,BASE		;A1=[08H]-READ/[0BH]-TEST
      	DW	ISRA2,BASE		;A2=[02H]-WRITE/[01H]-WARD
      	DW	ISRA3,BASE		;A3-JMP TO COMMAND MODE
      	DW	ISRA4,BASE		;A4-JMP TO CMDWDP
      	DW	ISRA5,BASE		;A5=EQU-CF IN 8085
      	DW	ISRA6,BASE		;A6-RD79
      	DW	ISRA7,BASE		;A7-WR79
      	DW	ISRA8,BASE		;A8-RD51
      	DW	ISRA9,BASE		;A9-WR51
      	DW	ISRAA,BASE		;AA-DELAY =CX*17+144 STATES
      	DW	ISRAB,BASE		;AB-CRET
      	DW	ISRAC,BASE		;AC-CRLF
      	DW	ISRAD,BASE		;AD-NMIN
      	DW	ISRAE,BASE		;AE-NMOUT
      	DW	ISRAF,BASE		;AF-OUTMSG
      	DW	ISRB0,BASE		;B0-WRTCARE
      	DW	ISRB1,BASE		;B1-MOVIMD
      	DW	ISRB2,BASE		;B2-PRINTER ENABLE/DISABLE AL="P"/NULL
      	DW	ISRB3,BASE		;B3-SET SERIAL-BAUD RATE IN CX
					;PARITY-AL=NULL/O/E,ALSO INIT 53,51
      	DW	ISRB4,BASE		;B4-LPRINT ASCII CHR IN AL
      	DW 	ISRB5,BASE		;B5-SETLIN USING AL- LINCUR=L00-07R
      	DW	ISRB6,BASE		;B6-BRANCH
      	DW	ISRB7,BASE		;B7-MULTMSG
      	DW	ISRB8,BASE		;B8-RDCRES
      	DW	ISRB9,BASE		;B9-RCVNO
      	DW	ISRBA,BASE		;BA-DISLAY CHR IN AL USING INT 0A2
      	DW	ISRBA,BASE		;BB-WRTENB
      	DW	ISRBC,BASE		;BC-WRTDSB
      	DW	ISRBD,BASE		;BD-DSPCOM
      	DW	ISRBE,BASE		;BE-STOINT GIVEN AL & CX:SI
      	DW	ISRBF,BASE		;BF-RDBYT [CX:SI]-->AL
	
	EVEN
RWTBL	DW "XA",2020H,"XB",2020H,"XC",2020H
	;   0		1	      2				
	DW "XD",2020H,"XF",2020H,"IS",2020H,"ID",2020H,"PB",2020H
	;   3		4	      5		   6		7
	DW "PS",2020H,"PI",2020H,"SC",2020H
	;   8		9	      A	  
	DW "SD",2020H,"SE",2020H,"SS",0303H
	;   B		 C	      D	   
CMDTBL  DB "SRMCGANUIBTPWDKJ",NULL

SIGNON	DB "ANSHUMAN",ETX
	EVEN
MGCMD	DB "COMMAND=",ETX
	EVEN
MGDONE  DB "DONE",ETX
MGSUB   DB "SUBSTUT?",ETX
MGSERIL DB "SERIAL?",ETX
MGMOV	DB "MOVE?",ETX
MGCOMP	DB "COMPARE?",ETX
MGGOTO	DB "GOTO?",ETX
MGRKBS	DB "RKBSEND?",ETX
MGRKBR	DB "RKBREC?",ETX	
MGSEROP DB "SERILOP?",ETX
MGSERIN DB "SERILIN?",ETX
MGBLANK	DB "BLANK?",ETX
MGCOPY	DB "COPY?",ETX
MGPROG	DB "PROGRAM?",ETX
MGPRON	DB "PRINT ON",ETX
MGPROF	DB "PRINT OF",ETX
MG7SEG	DB "7SEGMET?",ETX
MGKBD	DB "KEYBORD?",ETX		
MGMEMT	DB "ME TEST?",ETX
MGAYS	DB "SURE?",ETX
MUMSG1	DB "MEMORY",ETX
	DB "IO",ETX
	DB "REGISTER",ETX
MUMSG2  DB "INPUT",ETX
	DB "OUTPUT",ETX
MUMSG3  DB "BLOCK",ETX
	DB "CONSTANT",ETX
MUMSG4	DB "PRGM",ETX
	DB "SSTP",ETX
	DB "BSTP",ETX
MUMSG5	DB "INTELHEX",ETX
	DB "BINARY",ETX
MUMSG6	DB "L BYTE",ETX
	DB "H BYTE",ETX
	DB "WORD",ETX
MUMSG7 	DB "P SOKET",ETX
	DB "M SOKET",ETX
MGTYPE	DB "TYPE",ETX 
MGSTRT  DB "STRT",ETX
MGEND   DB "END",ETX
MGDSTN  DB "DSTN",ETX
MGSEGS  DB "SRC-SEGM",ETX
MGSEGD	DB "DST-SEGM",ETX
MGADDR  DB "ADDR",ETX
MGPC7	DB "PC7 BAD?",ETX
MGPORT  DB "PORT ADR",ETX
MGWORD  DB "DATA",ETX
MGBYTE	DB "BYTE",ETX
MGNAME  DB "NAME",ETX
MGWAIT	DB "WAIT",ETX
MGCONT	DB "COUNT",ETX
MGCSER	DB "CS ERR",ETX
MGCOLER	DB "COLON ER",ETX
MGFORMER DB "FORMAT?",ETX
MGRCVER	DB "RCV ERR",ETX		;ERROR IN RECEPTION
MGSTARS DB "******************************************************",ETX
MGFLAGS DB "XX XX XX XX OF DF IF TF SF ZF XX AF XX PF XX CF",ETX
TBLBAUD DW 0110H,0300H,0600H,1200H,2400H,4800H,9600H,1902H,0303H
TBL8253	DW 052DH,01E6H,00F3H,0079H,003DH,001EH,000FH,0008H,0303H	
TBLAS7S DW 3F30H,0631H,5B32H,4F33H,6634H,6D35H,7D36H,0737H,7F38H
	DW 6F39H,7741H,7C42H,3943H,5E44H,7945H,7146H,3D47H,7648H
	DW 0F49H,1E4AH,704BH,384CH,554DH,374EH,5C4FH,7350H,6751H
	DW 5052H,6D53H,7854H,3E55H,6256H,6A57H,6458H,6E59H,1B5AH
	DW 483DH,462BH,402DH,4C3EH,583CH,0D33FH,8621H,802AH,0020H,0000H	
TBLASHX DW 49FEH,7FFDH,3DFCH,4AFBH,4EFAH,38F9H,2AF8H,55F6H,39F5H
	DW 30F4H,48F3H,42F2H,37F1H,22F0H,59EEH,4FEDH,50ECH,47EBH
	DW 56EAH,36E9H,09E8H,54E6H,46E3H,43E2H,35E1H,2EE0H,52DEH
	DW 44DBH,58DAH,34D9H,2CD8H,45D6H,53D3H,5AD2H,33D1H,2FD0H
	DW 57CEH,4BCDH,4CCCH,41CBH,32C9H,03C8H,51C6H,4DC5H,0DC4H
	DW 1BC3H,20C2H,31C1H,3AC0H,2082H,69BEH,2BBCH,6ABBH,6EBAH,5FB9H
	DW 3EB8H,75B6H,28B5H,29B4H,68B3H,62B2H,26B1H,3CB0H,79AEH
	DW 6FADH,70ACH,67ABH,76AAH,5EA9H,74A6H,66A3H,63A2H,25A1H
	DW 729EH,649BH,789AH,2499H,6596H,7393H,7A92H,2391H,3F90H
	DW 778EH,6B8DH,6C8CH,618BH,4089H,7186H,6D85H,2181H,3B80H
	DW 097EH,0A7BH,0E7AH,0275H,0873H,0F6DH,076BH,3B6AH,1269H
	DW 1466H,0663H,0362H,185EH,0556H,1353H,0B4DH,0C4CH,1146H
	DW 7F45H,1544H,0000H 
TBLASX  DW 47F5H,1BF4H,4DF3H,53F2H,45EDH,44ECH,50EBH,0DEAH,41E7H
	DW 42E6H,43E3H,46E2H,39D7H,36D6H,37CFH,38CEH,35C9H,34C8H
	DW 32C7H,33C6H,31C1H,30C0H,52B5H,4FB4H,4CB3H,48B2H,4AADH
	DW 55ACH,54ABH,20AAH,4EA7H,51A6H,49A3H,57A2H,2D97H,2F96H
	DW 2C8FH,2E8EH,5A89H,5988H,5687H,5886H,5281H,4B80H,0275H
	DW 2074H,0A73H,2072H,146DH,136CH,0C6BH,156AH,2B67H,1166H
	DW 1263H,7F62H,3D57H,2656H,284FH,294EH,2A49H,2548H,2347H
	DW 2446H,4041H,2140H,2035H,2034H,2033H,2032H,202DH,0E2CH
	DW 202BH,032AH,5F27H,2026H,0F23H,0722H,3F17H,3B16H,3C0FH
	DW 3E0EH,3A09H,2008H,2007H,2006H,2001H,0000H
PONFJMP	DW 0000H,1000H	;POWER ON FAR JMP IS EXECUTED IN KIT
			;IF IR2 IS MADE HIGH AT POWER ON.
			;BY RESISTOR IT IS PULLED LOW. 	
SPEXE	DW ?		;NOP,DIRECT FAR JUMP
	DW ?		;IP TO BE STORED
	DW ?		;CS TO BE STORED
SPSTRT  DW ?
SPEND   DW ?
SPDSTN  DW ?
SPSEGS  DW ?
SPSEGD  DW ?
LINCUR  DB ?
TMPBYT	DB ?
TMPWRD	DW ?
SPCOMND	DB ?		;STORES COMMAND KEY IF REQUIRED
SPTYPE	DW ?		;EPROM TYPE --LAST  4 DIGITS,764A,7256
SPSOKET	DW ?		;SOCKET -P OR M ?
SPPORT  DW ?
SPIODT  DW ?
SPRGXX	DW 15 DUP(?)	;REGS STORAGE
SPWORD	DW ?
SPGSUB	DB ?		;IN GOTO-P,B,S
SPSTPC	DB ?		;INTERNAL COUNT TO DO SSTP
SPBSTP	DB ?		;BSTEP
SPCONT	DW ?		;COUNT FOR MULTIPLE LOOP
SPLES	DW ?		;AX TO BE STORED
	DW ?		;ES TO BE STORED
SPBBYTE DB ?		;TO STORE BREAK ADDR CONTENTS-
SPCONSOL DW ?		;1st BYTE=CONSOLE IN INT NO,2nd=CONSOL OUT INT NO
SPBAUD	DW ?		;BAUD RATE FOR 8251
SPPARIT DB ?		;PARITY=NULL/O/E
SPECHO	DB ?		;"E"-ECHO,NUL--NO ECHO
SPPRINT DB ?		;"P" FOR PRINTER ENABLE
SCREND	DB ?		;END OF SCRATCH PAD 
STOSEG	DW ?		;DS
	DW ?		;SS
	DW ?		;ES
	DW ?		;SP
RESET:	@IS			;INIT IF ON KIT AND SAVE IT AT STORAGE
	PUSH ES
SALOOP:	@PCK1			; MACRO TO LOAD SI,CX FOR MOVTOP
	XOR AX,AX
	MOV ES,AX		;INIT OF ES	
	@N MOVTOP		;INIT OF INTERRUPTS
	@N CMPMEM		;COMPARE AREAS
	JNZ SALOOP		;TO CREATE SA.	
	POP ES			;RESTORE ES
	@N INISCP		;INIT OF SCRATCH PAD	
	@N INI55		;8255	
	@N INI79		;8279
	@N INI53		;8253
	@N INI59		;8259
	@N INI51		;8251		
	@PCK3			;LOADS ADDRS' OF ISR01,0A5 ETC,KIT-3*NOP'S
	NOP
	NOP
	NOP
	NOP
	NOP
	@PCK2			;CONSOLE NO OUT-IN [LB]
CHNGIO:	@ES AX,SPCONSOL,0
	@N SETIO
	RET
LDINPC	ENDP
MOVTOP	PROC NEAR
;SI[DS]-SRC,CX-END,DI-DSTN[ES].ONLY MOVES BLOCK,NO VERIFY
	PUSHF
	@PH
	CMP CX,SI
	JC MSKP01		;CF=1-CX<SI,DON'T MOVE
MLUP01:	MOV AL,[SI]
	MOV ES:[DI],AL		;USE ES:DI PAIR TO
				;WRITE INTO B-RAM
	CMP CX,SI
	JZ MSKP01		;OVER
	INC SI
	INC DI
	JMP NEAR PTR MLUP01
MSKP01:	@PP
	POPF
	RET 
MOVTOP	ENDP
MOVBOT	PROC NEAR
;SI[DS]-SRC,CX-END,ES:DI-DSTN,MOVEMENT BEGINS FROM END,DSTN END AUTODETERMINED
	PUSHF
	@PH
	XCHG CX,SI
	MOV BX,SI		;SAVE END
	SUB SI,CX
	JC MBSK01		;END<STRT- >DON'T MOVE
	ADD DI,SI		;GET END OF DSTN AREA
 	MOV SI,BX
MBLP01:	MOV AL,[SI]
	MOV ES:[DI],AL		;FETCH & STORE
	CMP SI,CX
	JZ MBSK01
	DEC SI
	DEC DI
	CMP SI,CX
	JNC MBLP01
MBSK01: @PP
	POPF
	RET
MOVBOT  ENDP	
MOVIMD	PROC NEAR
;DS:SI-STRT,CX-END,AL=BYTE,MOVE IMMEDIATELY
	PUSHF
	@PH
	CMP CX,SI
	JC MISK01		;END<STRT,DON'T MOVE
MILP01:	MOV [SI],AL
	CMP CX,SI
	JZ MISK01		;END REACHED
	INC SI
	JMP NEAR PTR MILP01
MISK01: @PP
	POPF
	RET
MOVIMD  ENDP
CMPMEM	PROC NEAR
;SI[DS]-SRC,CX-END,DI-DSTN[ES].ONLY COMPARES BLOCK,ZF=1 MATCH
	PUSH AX
	PUSH SI
	PUSH DI
	CMP CX,SI
	JC CPSK01		;CF=1-CX<SI
CPLP01:	MOV AL,ES:[DI]
	CMP [SI],AL		;USE ES:DI PAIR TO
	JNZ CPSK02		;ERROR,MISMATCH
	CMP CX,SI
	JZ CPSK01		;END REACHED
	INC SI
	INC DI
	JMP NEAR PTR CPLP01
CPSK01: XOR AX,AX		;ZF=1,DESTROY NOTHING ELSE
	POP DI
	POP SI
	POP AX
	RET
CPSK02: POP AX			;ZF=0,CY=1/0 AS [DI]<>[SI]
	POP AX
	POP AX
	RET
CMPMEM  ENDP
CMPIMD	PROC NEAR
;DS:SI-STRT,CX-END,AL=BYTE,COMPARE IMMEDIATELY
	PUSH AX
	PUSH SI
	CMP CX,SI
	JC CMSK01		;END <STRT DON'T MOVE
CMLP01:	CMP [SI],AL
	JNZ CMSK02
	CMP CX,SI
	JZ CMSK01		;END REACHED
	INC SI
	JMP NEAR PTR CMLP01
CMSK01: XOR AX,AX		;ZF=1 MATCH
	POP SI
	POP AX
	RET	
CMSK02: POP AX			;Z=0 ERROR,C=1/0 AS [SI]<>BYTE
	POP AX 
	RET
CMPIMD  ENDP
OUTMSG  PROC NEAR
;BX-POINTER TO STRING OF ASCII ENDING ETX ,SENT TO
;PRESENT CONSOLE OUTPUT
	@P1
OLUP01: MOV AL,[BX]
	CMP AL,ETX 		;ETX-END OF STRING
	JZ OSKP01
	@N WR			;FOR SAKE OF FUN CALL
				;WRITES A CHARACTER
	INC BX
	JMP NEAR PTR OLUP01
OSKP01: @P2
	RET
OUTMSG  ENDP
INISCP  PROC NEAR	
	;PUTS 00 FROM ALL AREA AFTER INT,0000:0X00 [UPTO 06FF 1S STACK AREA] 
	;ONWARDS UPTO 0XFF.
	;THEN SPECIFIC LOCATIONS ARE LOADED WITH CONSTANTS LIKE BAUD
	@PU
	MOV AX,ES		;SINCE ROUTINE REQUIRES DS:SI
	MOV DS,AX		;FETCH ES IN DS
	@M SI,ES:SPSTRT
	@M CX,ES:SCREND
	@N MOVIMD
	@N CMPIMD
INSLP01:JNZ INSLP01		;SCRATCHPAD BAD HENCE LOOP TO CREATE SA
	MOV AX,2400H		;BAUD RATE SET TO 2400
	@ES AX,SPBAUD,0
	MOV AL,NULL		;PARITY 00/"O"/"E"
	@ES AL,SPPARIT,0
	@PO
	RET
INISCP	ENDP
INI55   PROC NEAR
	@P1
	MOV DX,8807H		;PORT C OUT,REST IN MODE
	MOV AL,92H
	OUT DX,AL
	MOV DX,8805H		;8255 L
	MOV AL,0DBH
	OUT DX,AL
	@P2
	RET
INI55	ENDP
INI79   PROC NEAR
	@P1
	MOV DX,9C03H
	MOV AL,0D3H
	OUT DX,AL
	MOV AL,0A3H
	OUT DX,AL
	MOV AL,37H
	OUT DX,AL
	MOV AL,00H
	OUT DX,AL
	MOV AL,0A0H
	OUT DX,AL
	@P2
	RET
INI79	ENDP
INI53	PROC NEAR
	@PU
I53LP01:@EF CX,SPBAUD,0
	@M SI,TBLBAUD
	@N DWCMP
	JC I53SK01
	MOV CX,2400H
	@ES CX,SPBAUD,0
	JMP NEAR PTR I53LP01
I53SK01:MOV AH,00H
	SAL AX,1
	@M SI,TBL8253
	ADD SI,AX
	MOV CX,[SI]		;FETCH COUNT FOR 8253
	MOV DX,8C42H
	MOV AL,36H
	OUT DX,AL
	MOV DX,8C00H
	MOV AL,CL
	OUT DX,AL
	MOV AL,CH
	OUT DX,AL
	@PO
	RET
INI53	ENDP
INI59	PROC NEAR
	RET
INI59	ENDP
INI51	PROC NEAR
	PUSHF
	PUSH DX
	MOV DX,9002H
	MOV AL,00H
	OUT DX,AL
	@DL 000FH
	OUT DX,AL
	@DL 000FH
	OUT DX,AL
	@DL 000FH
	MOV AL,40H
	OUT DX,AL
	@DL 000FH
	MOV AL,0CEH	
	@EF AH,SPPARIT,0
	CMP AH,NULL
	JZ I51SK01
	OR AL,10H
	AND AL,0FBH		;PARITY ENABLED-->CHR=7 BITs+1 PARITY
	CMP AH,"O"
	JZ I51SK01
	OR AL,20H		;EVEN--->1	
I51SK01:OUT DX,AL		;MODE CONTROL WORD
	@DL 000FH
	MOV AL,37H		;COMMAND WORD
	OUT DX,AL
	@DL 000FH
	IN AL,DX
	@PCK14		;AL=/=0--->8251 ERROR CONDITION
	POP DX
	POPF
	RET
INI51	ENDP
SETIO	PROC NEAR
	;GIVEN CONSOLE DEFn IN AX,OUT/IN(LB),CRRESPONDING LOCnS ARE TRANS
	;-FERRED TO A1,0A2 INT'S
	@PU
	MOV DX,AX
	JMP SHORT STSK01		;WORKING ON PC
	XOR AH,AH			;X
	@M BX,INTXX			;X
	ADD BX,AX			;X
	LES SI,[BX]			;XFETCH CONTENTS IN ES:SI NEW CON IN
	PUSH ES				;X
	POP CX				;X
	MOV AL,0A1H	 		;X
	@N STOINT			;X STORE AT INT 0A1H
	JMP NEAR PTR CONOUT			;X
STSK01: @N FTHINT			;FETCH PRESENT PC CON ADDR
	MOV AL,0A1H
	@N STOINT
CONOUT: MOV AX,DX
	CMP AH,21H
	JMP SHORT STSK02
	MOV AL,AH			;X
	SAL AL,1			;X
	SAL AL,1			;X
	XOR AH,AH			;X
	@M BX,INTXX			;X
	ADD BX,AX			;X
	LES SI,[BX]		;X FETCH NEW CON OUT IN ES:SI
	PUSH ES			;X
	POP CX			;X
	MOV AL,0A2H		;X
	@N STOINT		;X
	JMP NEAR PTR SETEND		;X
STSK02: MOV AL,AH
	@N FTHINT
	MOV AL,0A2H
	@N STOINT
SETEND: @PO
	RET
SETIO   ENDP			
LDINTS	PROC NEAR
	;USEFUL ONLY ON PC.LOADS ADDR OF INT01,0A5 AT 0000:NO
	;USEFUL EVEN IN KIT,NO NEED TO DEFINE BASE ADDR,NO NEED 
	@PU
	PUSH CS
	POP CX
	@SI ISRA3,0A3H
	@SI ISRA4,0A4H
	@SI ISRA5,0A5H
	@SI ISRA6,0A6H
	@SI ISRA7,0A7H
	@SI ISRA8,0A8H
	@SI ISRA9,0A9H
	@SI ISRAA,0AAH	
	@SI ISRAB,0ABH
	@SI ISRAC,0ACH
	@SI ISRAD,0ADH
	@SI ISRAE,0AEH
	@SI ISRAF,0AFH
	@SI ISRB0,0B0H
	@SI ISRB1,0B1H
	@SI ISRB2,0B2H
	@SI ISRB3,0B3H
	@SI ISRB4,0B4H
	@SI ISRB5,0B5H
	@SI ISRB6,0B6H
	@SI ISRB7,0B7H
	@SI ISRB8,0B8H
	@SI ISRB9,0B9H
	@SI ISRBA,0BAH
	@SI ISRBB,0BBH
	@SI ISRBC,0BCH
	@SI ISRBD,0BDH
	@SI ISRBE,0BEH
	@SI ISRBF,0BFH
	@PO
	RET
LDINTS	ENDP
CRLF	PROC NEAR
;OUTPUTS CR THEN LF TO CONSOLE OP
	@P1
	MOV AL,CR
	@N WR
	MOV AL,LF
	@N WR
	@P2
	RET
CRLF	ENDP
STOINT  PROC NEAR
;GIVEN CX:SI AS ADDR,AL=INT NO,IT STORES IN 0000 RAM
	@PU
	CLI
	XOR DX,DX
	MOV ES,DX
	MOV AH,00H
	SAL AX,1
	SAL AX,1		;*4
	MOV DI,AX
	MOV ES:[DI],SI		;FIRST SAVE SI 
	INC DI
	INC DI	
	MOV ES:[DI],CX		;SAVE CX=SEG
	@PO
	RET
STOINT  ENDP
FTHINT	PROC NEAR
	;GIVEN AL=INT NO,THE CONTENTS OF IT ARE FETCHED IN CX:SI
	@P1
	PUSH ES
	MOV AH,00H
	SAL AX,1
	SAL AX,1
	MOV BX,AX
	XOR AX,AX
	MOV ES,AX
	LES SI,ES:[BX]
	PUSH ES
	POP CX
	POP ES
	@P2
	RET
FTHINT	ENDP	
AUTHR   PROC NEAR
;DISPLAYS MSG AS PER BX
	@N CRLF
	@N OUTMSG
	@N RDCRES
	RET			;Z=1>AUTHORISED	AND CF=1/0 FOR CR/NAK
AUTHR   ENDP
BRANCH  PROC NEAR
;GIVEN SI TO CMDTBL,BX TO JMPTBL,AL=KEY THEN FINDS MATCH IN
;CMDTBL .TILL THEN INC BX.MATCH>CF=1,ELSE CF=0
	PUSH SI
	PUSH AX
BLUP01:	MOV AH,[SI]		;FETCH FROM TABLE
	CMP AH,NULL		;END ENTRY?
	JZ BSKP01
	CMP AH,AL
	JZ BSKP02		;MATCH FOUND
	INC SI
	INC BX 			;ADJUST JMP POINTER
	INC BX
	INC BX
	JMP NEAR PTR BLUP01
BSKP02: STC
BSKP01: POP AX
	POP SI			;CF=1>HL=APPROPRIATE JMP ADDR
	RET			;ELSE CF=0
BRANCH  ENDP

NEXSTR	PROC NEAR
	MOV AL,00H
NELUP01:CMP BYTE PTR [BX],ETX
	JZ NESKP01		;STRING END
	INC BX
	INC AL
	JMP NEAR PTR NELUP01
NESKP01:INC BX			;BX TO FOLLOWING STRING
	RET
NEXSTR  ENDP

MULTMSG PROC NEAR
;BX= POINTS TO GROUP OF MESSAGES,AL=NO.OF MSG'S,CHOICE BY CR WITH
;APPROPRIATE AL,ESC RTURNS TO CMDMOD,ANY OTHER KEY FOR NEXT DISPLAY
	PUSH CX
	PUSH BX
	MOV CH,AL		;SAVE COUNT
MULUP02:MOV CL,CH
MULUP01:@N CRLF
	@N OUTMSG
	@N RDCRES		;READ,DISTINGUISH CR,ESC TO CMD
	JZ MUSK01		;CHOSEN
	
	@N NEXSTR	
	DEC CL
	JNZ MULUP01
	POP BX
	PUSH BX
	JMP NEAR PTR MULUP02
MUSK01:	MOV AL,CH
	SUB AL,CL		;AL=1 2 3 ETC DEPENDING SR NO
	INC AL
	POP BX 			;OF MESSAGE
	POP CX
	RET
MULTMSG ENDP
SFCDX	PROC NEAR
;SHIFTS CX-DX PAIR LEFT BY 4 BIT POS
	PUSHF
	SAL DX,1
	RCL CX,1
	SAL DX,1
	RCL CX,1
	SAL DX,1
	RCL CX,1
	SAL DX,1
	RCL CX,1
	POPF
	RET
SFCDX	ENDP
NMOUT	PROC NEAR
;GIVEN RT HAND JUSTIFIED NO IN CX-DX ,AL=NO OF DIGITS,DISP
;FROM PRESENT CURSOR POS
	@P1
	PUSH CX
	MOV AH,08H
	SUB AH,AL
        JZ NMLUP02		;TO CREAT RT HAND JUSTIFIED NO
NMLUP01:@N SFCDX
	DEC  AH
	JNZ NMLUP01
NMLUP02:MOV AH,CH
	AND AH,0F0H
	SHR AH,1
	SHR AH,1
	SHR AH,1
	SHR AH,1		;BRING DIGIT TO L NIBBLE
	@N DGOUT		;GIVEN DIG IN CH,OUTPUT IT
	@N SFCDX
	DEC AL			;DIGITS OVER?
	JNZ NMLUP02
	POP CX
	@P2
	RET
NMOUT	ENDP
DGOUT	PROC NEAR
;GIVEN NO IN AH [L NIBBLE],IT IS OUT TO PRESENT CURSOR POS
	PUSH AX
	PUSH DX
	MOV AL,AH
	AND AL,0FH
	CMP AL,0AH
	JNC DGSK01
	ADD AL,30H
	JMP SHORT DGSK02
DGSK01: ADD AL,37H		;MAKE ASCII
DGSK02:	@N WR
	POP DX 
	POP AX
	RET
DGOUT   ENDP		
OUT7SEG PROC NEAR
	;GIVEN CHR IN AL,IT IS OUTPUT AT PRESENT CURSOR POS ,ALSO INCR
	;LINCUR AFTER OUTPUTTING
	@P1
	@EF AH,LINCUR,0
	AND AH,07H
	OR AH,90H
	MOV DX,9C03H
	XCHG AH,AL
	OUT DX,AL
	MOV DX,9C01H
	MOV AL,AH
	NOP
	OUT DX,AL
	@EF AH,LINCUR,0
	INC AH
	@ES AH,LINCUR,0
	@P2
	RET
OUT7SEG ENDP
LINSRH  PROC NEAR
	;GIVEN TABLE POINTER IN SI[DS],DL=INCOMING CODE FOR MATCHING
	;CF=1---NOMATCH,ELSE MATCH THEN AL=CONVERTED CODE FROM 2nd byte
	;ofENTRY
	PUSH SI
	PUSH CX
	MOV CL,00H
LNLP01:	CMP BYTE PTR [SI],CL
	JNZ LNSK01
	STC
	JMP NEAR PTR LNEND		;END OF TABLE
LNSK01: CMP BYTE PTR [SI],DL
	JNZ LNSK02
	INC SI			;MATCH FOUND,FETCH 7 SEG CODE
	MOV AL,BYTE PTR [SI]	
LNEND:	POP CX			;CF=1-->MISMATCH 
	POP SI			;C=0--MATCH
	RET
LNSK02: INC SI
	INC SI
	JMP NEAR PTR LNLP01
LINSRH  ENDP
RDCRES  PROC NEAR
;READS KBD,FINDS IF CR PRESSED>ZF=1,CF=1,NAK Z=1C=0
;IF ESC PRESSED >JUMPS TO CMDMOD ELSE RETURNS
	MOV AH,08H
	INT 0A1H
	CMP AL,ESC
	JNZ RDSK02
	JMP NEAR PTR CMDMOD
RDSK02:	CMP AL,NAK
	JZ RESKP01		;Z=1,C=1 FOR CR
	CMP AL,CR
	JNZ RESKP01
	STC			;Z=1 C=0 FOR NAK
RESKP01:RET			;ZF=0 FOR OTHER KEYS
RDCRES  ENDP
NMINRV	PROC
	; LIKE NMIN BELOW EXCEPT ENTRY WITH KEY ALREADY RECEIVED
	;USED IN RCVNO
	PUSH BX
	MOV BX,AX
	PUSH BX
	@N RDCRES
	@N CRLF
	JMP NEAR PTR NMIN2
NMINRV	ENDP
NMIN	PROC NEAR
;INPUT-DEFAULT SET NO IN CX-DX,AL=NO OF DIGITS,AH=NO.SYSTEM
;10 FOR HEX,0A FOR DEC ETC.CORRECT ENTRY Z=1,CY=1/0 FOR CR/NAK
;ERRONEOUS ENTRY Z=0
	PUSH BX
	MOV BX,AX
	PUSH BX
	@N RDCRES
NMIN2:	JNZ NMSK02		;PROCESS KEY
	JMP NEAR PTR NMSK01		;CR PRESSED
NMLP01:	@N RDCRES
	JZ NMSK03		;REGULAR END
NMSK02:	SUB AL,"0"
	JC ERROR		;KEY<"0"
	CMP AL,0AH
	JC NMSK04		;KEY BETWEEN 0-9
	SUB AL,07H
	CMP AL,0AH
	JC ERROR
	CMP AL,10H
	JNC ERROR		;KEY BETWEEN A-F
NMSK04: CMP AL,BH		;CHECK NO SYSTEM
	JNC ERROR	
	@N SFCDX
	OR DL,AL
	OR BL,BL		;NO OF ENTRIES=NO OF DIGITS
	JZ NMSK05
NMLP03:	MOV AH,DL
	@N DGOUT
	DEC BL
	JMP NEAR PTR NMLP01	
NMSK05: POP BX
	PUSH BX			;RESTORE NO OF DIGITS COUNT
	MOV AH,BL
	MOV AL,ES:[LINCUR]
	DEC AL
NMLP02:	MOV ES:[LINCUR],AL
	MOV AL,00H		;BLANK CODE
	@N OUT7SEG		;DON'T DESTROY AH
	MOV AL,ES:[LINCUR]
	DEC AL
	DEC AL
	DEC BL
	JNZ NMLP02
	INC AL
	MOV ES:[LINCUR],AL 
	MOV BL,AH
	JMP NEAR PTR NMLP03
NMSK01:	MOV AX,BX		;RESTORE AL,AH
	@N NMOUT		;SAVE FLAGS
NMSK03:	NOP
	POP AX		;Z=1 OK ENTRY CF=1/0>CR/NAK
	POP BX
	RET
ERROR:  MOV AX,BX
	OR AX,AX
	STC		;C=1,Z=0>ERROR
	JMP SHORT NMSK03
NMIN	ENDP	
RCVNO	PROC NEAR
;BX=POINTER TO TITLE,DEFAULT SET NO IN CX-DX,AL=NO OF DIGITS TO BE
;RECEIVED,AH=NO SYSTEM,RECEIVE TILL CR/NAK,ESC TO CMDMOD
	@N CRLF
	@N OUTMSG		;DISPLAY TITLE 
	@N NMINRV
	JNZ RCVNO		;Z=0>WRONG ENTRY
	RET
RCVNO	ENDP	
WR	PROC NEAR
;CHR IN AL ,DISPLAYS
	PUSH AX
	PUSH DX
	MOV DL,AL
	MOV AH,02H
	INT 0A2H
	POP DX
	POP AX
	RET
WR	ENDP 
RDBYT	PROC NEAR
;GIVEN CX-SI AS ADDR,READS BYTE IN AL.DESTROY NONE(AL)
	PUSH DS
	MOV DS,CX
	MOV AL,[SI]
	POP DS
	RET
RDBYT	ENDP
WRBYT	PROC NEAR
;CX-SI AS POINTER ,AL=DATA THEN WRITE IT TAKING CARE OF WRT PROTECT
;CX SEGMENT ADDR
	@PU
	MOV BX ,AX		;SAVE AL
	MOV DX,PORTC
	IN AL,DX
	MOV ES:[TMPBYT],AL
	XOR AL,80H
	OUT DX,AL	
	IN AL,DX
	XOR AL,ES:[TMPBYT]	;THIS IS TO IDENTIFY WHETHER PC7 IS
				;OUT BIT OR NOT
	@PCK4			;PLACE FOR JZ WRSK01
	MOV AL,ES:[TMPBYT]
	AND AL,7FH
	OUT DX,AL			;ENABLE LPC7 OUT DX,AL
	MOV DS,CX 		;SET SEG WITH CX
	MOV BH,AL		;RESTORE AH AS PORT DATA
	MOV AX,BX
	MOV [SI],AL
	OR AH,80H
	MOV AL,AH
	OUT DX,AL
	@PO
	RET
WRSK01: @N CRLF			;PORT C CONFIG CHANGED
	@M BX,MGPC7 
	@N OUTMSG
	@PO
	RET					;					
WRBYT	ENDP
EXWORD	PROC NEAR
;GIVEN ADDR IN CX:SI,WORD IN AX,IT IS EXCHANGED WITH WORD POINTED
;TO BY CX:SI.NO DESTROYED.
	PUSHF
	PUSH BX
	MOV BX,AX		;SAVE
	@N RDBYT		;FETCH 1st BYTE
	MOV AH,AL		
	INC SI
	@N RDBYT		;2nd BYTE
	XCHG AH,AL		;SET ORDER RIGHT
	XCHG BX,AX		;INPUT NO BROUGHT IN AX,BX=OUTPUT NO
	XCHG AH,AL
	@N WRBYT		;WRITE UPPER BYTE
	MOV AL,AH		;WRITE LOWER BYTE
	DEC SI
	@N WRBYT		;TAKES CARE OF WRITE PROTECT
	MOV AX,BX
	POP BX
	POPF
	RET
EXWORD  ENDP
WRTENB	PROC NEAR
	PUSH AX
	PUSH DX
	MOV DX,PORTC
	IN AL,DX
	MOV ES:[TMPBYT],AL
	XOR AL,80H
	OUT DX,AL	
	IN AL,DX
	XOR AL,ES:[TMPBYT]	;THIS IS TO IDENTIFY WHETHER PC7 IS
				;OUT BIT OR NOT
	@PCK5			;PLACE FOR JZ WEBSK01
	MOV AL,ES:[TMPBYT]
	AND AL,7FH
	OUT DX,AL			;ENABLE LPC7 OUT DX,AL
	POP DX
	POP AX
	RET
WEBSK01:MOV DX,8807H		;IN CASE USER HAS CHANGED PC7 TO
				;SOME OTHER MODE THEN REINIT
	MOV AL,92H
	OUT DX,AL
	MOV DX,8805H		;8255 L
	MOV AL,05BH		;WRITE ENABLE
	OUT DX,AL
	POP DX
	POP AX
	RET
WRTENB	ENDP
WRTDSB	PROC NEAR
	PUSH AX
	PUSH DX
	MOV DX,8805H		;8255 L
	MOV AL,0DBH		;WRITE DISABLE
	OUT DX,AL
	POP DX
	POP AX
	RET
WRTDSB	ENDP
DWCMP	PROC NEAR
;USES SI AS POINTER TO TABLE [DS:],CX IS COMPARED WITH
;TABLE ENDS IN ETX*2,AL=SR NO COUNTER ,CF=1 >MATCH
	PUSH DX
	MOV DX,0303H
	MOV AL,00H
DWLP01:	CMP [SI],CX		;LOWER BYTE CL FIRST
	JZ DWSK01		;MATCH
	CMP [SI],DX
	JZ DWSK02		;TABLE OVER
	INC SI
	INC SI
	INC AL
	JMP NEAR PTR DWLP01
DWSK01:	STC			;CF=1 >MATCH,AL=SR NO-0 TO N-1 FOR N ENTRIES
DWSK02:	POP DX			;DESTROYS SI DI
	RET
DWCMP	ENDP
STREND	PROC NEAR
;RECEIVE STRT+SEG,END, SAVES THEM
	@PH
	PUSHF
	@R MGSEGS,SPSEGS,04H
	@R MGSTRT,SPSTRT,04H
	MOV SI,DX
RELU01:	@R MGEND,SPEND,04H
	CMP SI,DX			;STRT >END THEN TRY AGAIN
	JZ RESK01
	JNC RELU01
RESK01:	POPF
	@PP
	RET
STREND	ENDP
DSTNEND	PROC NEAR
;RECEIVE DSTN+SEG,END,SAVES THEM
	@PH
	PUSHF
	@R MGSEGD,SPSEGD,04H
	@R MGDSTN,SPDSTN,04H
	MOV SI,DX
DSLP01:	@R MGEND,SPEND,04H	
	CMP SI,DX			;JG=IF GREATER
	JZ DSSK01
	JNC DSLP01
DSSK01:	POPF
	@PP
	RET
DSTNEND	ENDP
BYSTED	PROC NEAR
;RECEIVE BYTE THEN STRT END,BUT USE SPWORD TO CREATE MATCH OPERANDS
	@R MGBYTE,SPWORD,02H
	JMP NEAR PTR STREND
BYSTED	ENDP
STEDDN  PROC NEAR
	@N STREND
	@R MGSEGD,SPSEGD,04H
	@R MGDSTN,SPDSTN,04H	
	RET
STEDDN	ENDP
DISADT	PROC NEAR
;DISPLAY BX:DI & ITS BYTE CONTENT,BX BRINGS SEG CONTENT.ON NEW LINE.
	@PU
	@N CRLF
	MOV DX,DI
	MOV AL,04H
	@N NMOUT 
	MOV AL,SPC
	@N WR
	@N WR
	MOV DS,BX		;SET SEG INFORMATION
	MOV DL,[DI]
	MOV AL,02H
	@N NMOUT
	@PO
	RET
DISADT	ENDP
DISDIAL	PROC NEAR
;DISPLAYS FROM LINE BEGINNING DI AS ADDR ,AL AS BYTE CONTENT,USES CRET.
	@PU
	INT 0ABH
	MOV AH,AL	;SAVE BYTE
	MOV DX,DI
	MOV AL,04H
	@N NMOUT 
	MOV AL,SPC
	@N WR
	@N WR
	MOV DL,AH	;FETCH BYTE	
	MOV AL,02H
	@N NMOUT
	@PO
	RET
DISDIAL	ENDP
WAIT	PROC NEAR
	@P1
	@N CRLF
	@M BX,MGWAIT
	@N OUTMSG
	@P2
	RET
WAIT	ENDP
LDREGS	PROC NEAR
;USED IN GOTO,LOADS REGISTERS EXCEPT AX,SS,SP,ES,FX.ALSO LOADS AT ES:SPEXE
;90-EA-IPL-IPH-CSL-CSH
	MOV AX,0EA90H		;FAR JMP DIR+NOP
	@ES AX,SPEXE,0
	@EF AX,SPRGXX,12H
	@ES AX,SPEXE,02H	;STORE IP
	@EF AX,SPRGXX,14H
	@ES AX,SPEXE,04H	;STORE CS
	@EF BX,SPRGXX,2H	;BX
	@EF CX,SPRGXX,04H	;CX
	@EF DX,SPRGXX,06H	;DX
	@EF SI,SPRGXX,0AH	;SI
	@EF DI,SPRGXX,0CH	;DI
	@EF BP,SPRGXX,0EH	;BP
	@EF DS,SPRGXX,16H	;DS
	RET
LDREGS	ENDP
KEYIN	PROC NEAR
	;FETCHES HEX CODE IN DL
	MOV DX,9C03H
KYLP01:	IN AL,DX
	AND AL,0FH
	JZ KYLP01
	MOV AL,40H
	OUT DX,AL
	MOV DX,9C01H
	IN AL,DX
	MOV DL,AL
	RET
KEYIN	ENDP
SROUTX	PROC
	;GIVEN CHARACTER IN DL[ASCII ASSUMED],IT IS SENT OUT
	;USING XON[CNT Q 11H]-XOFF[CNT S 13H] PROTOCOL
	PUSH AX
	MOV AH,0BH		;FIRST TEST FOR XOFF
	INT 0A8H
	CMP AL,00H
	JNZ SXSK01
	JMP NEAR PTR SXSK02		;NO XON XOFF
SXSK01:	MOV AH,08H
	INT 0A8H		;READ THE CHR
	CMP AL,13H		;XOFF?
	JZ SXSK03
	JMP NEAR PTR SXSK02		;NO XOFF
SXSK03:	MOV AH,0BH		;TEST FOR XON
	INT 0A8H
	CMP AL,0FFH
	JNZ SXSK03
	MOV AH,08H
	INT 0A8H		;READ THE CHR
	CMP AL,11H		;XON?
	JNZ SXSK03
SXSK02:	MOV AH,02H
	@PCK6
	POP AX
	RET
SROUTX	ENDP
OUTASCI	PROC
	;GIVEN HEX CHR IN AL,FIRST SEND UPPER NIBLE THEN LOWER
	;NIBBLE OVER SERIAL LINK AFTER CONVERTING TO ASCII
	@P1
	@N BYTASCI
	MOV BX,AX
	MOV AH,02H
	MOV DL,BH
	@N SROUTX
	MOV DL,BL
	MOV AH,02H
	@N SROUTX
	@P2
	RET
OUTASCI	ENDP
BYTASCI PROC
	;GIVEN AL,GENERATE TWO ASCII CHRs IN-AH,AL-
	PUSH DX
	MOV DL,AL
	AND AL,0FH
	CMP AL,0AH
	JC BYSK01		;0-9
	ADD AL,37H
	JMP NEAR PTR BYSK02
BYSK01: ADD AL,30H
BYSK02: XCHG DL,AL
	SHR AL,01H
	SHR AL,01H
	SHR AL,01H
	SHR AL,01H
	CMP AL,0AH
	JC BYSK03		;0-9
	ADD AL,37H
	JMP NEAR PTR BYSK04
BYSK03: ADD AL,30H
BYSK04: XCHG DL,AL
	MOV AH,DL
	POP DX
	RET
BYTASCI ENDP
GETHEX	PROC
	;RECEIVES TWO ASCII ,CHECKS VALIDITY AS NUMERALS[HEX],IF NOT THEN 
	;RETURNS WITH CY=1 ELSE 0 COMPACTS THEM IN AL,UPPER NIBLE FIRST
	PUSH DX
	PUSH AX
	@PCK10			;ON PC AH=00==>NOERROR
	AND AH,38H		;ON KIT AH=70 FOR FE,OE PE ERRORS
	JZ GHSK04		;NO ERROR
	JMP NEAR PTR GHERR03		;EITHER OE OR FE OR PE
 GHSK04:SUB AL,"0"
	JC GHERR01		;KEY<"0"
	CMP AL,0AH
	JC GHSK01		;KEY BETWEEN 0-9
	SUB AL,07H
	CMP AL,0AH
	JC GHERR01
	CMP AL,10H
	JNC GHERR01		;NOT HEX	
GHSK01:	MOV DL,AL		;SAVE UPPER NIBLE
	@PCK10
	AND AH,38H	;CHECK STATUS WORD OF 8251
	JZ GHSK05		;NO ERROR
	JMP NEAR PTR GHERR03		;EITHER OE OR FE OR PE
GHSK05:	SUB AL,"0"
	JC GHERR02		;KEY<"0"
	CMP AL,0AH
	JC GHSK02		;KEY BETWEEN 0-9
	SUB AL,07H
	CMP AL,0AH
	JC GHERR02
	CMP AL,10H
	JNC GHERR02		;NOT HEX	
GHSK02: SAL DL,1		;FETCH LOWER NIBLE IN AL,DL=UPPER
	SAL DL,1
	SAL DL,1
	SAL DL,1
	OR DL,AL		;COMPACT IT
	POP AX
	MOV AL,DL
	OR AL,AL		;CY=0
	POP DX
	RET
GHERR01:NOP			;ERROR IN FIRST NIBBLE
GHERR02:MOV AL,0FFH		;ILLEGAL HEX Z=0,CY=1
GHERR03:MOV AL,00H
	OR AL,AL		;Z=1 IF ERROR IN RECEPTION	
	STC			;CY=1 --ERROR
	POP AX
	POP DX
	RET
GETHEX	ENDP
DONE	PROC NEAR
	@M  BX,MGDONE		;INT TYPE CALL
	JMP NEAR PTR DSPCOM
DONE	ENDP
DSPCOM	PROC NEAR
	@N CRLF
	@N OUTMSG
	RET	
DSPCOM  ENDP
DELAY	PROC NEAR
	PUSHF
	PUSH CX
DLY:	LOOP DLY		;EQU=17*CX+69 STATES
	POP CX	
	POPF
	RET
DELAY 	ENDP
PRENDS	PROC
	;PRINTER ENABLE [AL="P"]/DISABLE [AL=NULL OR X].REINITIALISES
	;8255 L FOR ENABLING.
	@PSP
	CMP AL,"P"
	JZ PEDSK01
	@SE
	@ES AL,SPPRINT,0
	@PSO
	RET
PEDSK01:@SE
	MOV AL,"P"
	@ES AL,SPPRINT,0
	MOV DX,8807H
	MOV AL,82H
	OUT DX,AL
	MOV DX,8805H		;8255 L
	@DL 0400H
	MOV AL,0FBH
	OUT DX,AL
	@DL 6000H		;TO COVER INTERNAL PRINTER DELAY
	@PSO
	RET
PRENDS	ENDP
SETSR	PROC
	;SETS BAUD RATE LOCATION USING CX,PARITY USING AL [E/O/NULL]
	;ANY GARBAGE SETS TO 2400, NULL PARITY.DOES INIT OF 8253,8251
	PUSH BX
	@PSP
	@ES CX,SPBAUD,0
	CMP AL,"E"
	JZ SSRSK01
	CMP AL,"O"
	JZ SSRSK01
	MOV AL,NULL
SSRSK01:@ES AL,SPPARIT,0
	@N INI53
	@N INI51
	MOV BX,AX
	@PSO
	MOV AL,BL
	POP BX		;IF ERROR THEN AL=00 1/0 1/0 1/0 000[38H]
	RET
SETSR	ENDP
LPRINT	PROC
	;GIVEN AL ASCII CHR,PRINTS AT PRESENT HEAD POSITION
	@P1
	MOV DX,8803H		;PORT B
	MOV BL,AL
LPLP01:	IN AL,DX
	MOV AH,AL
	AND AL,08H
	MOV AL,AH
	JNZ LPSK01		;PAPER END/ERROR
	AND AL,01H
	JNZ LPLP01		;BUSY?
	MOV AL,BL
	MOV DX,8801H
	OUT DX,AL		;PORTA
	MOV DX,8805H		;PORT C
	IN AL,DX
	AND AL,0EFH		;SET LOW
	OUT DX,AL
	NOP
	OR AL,10H
	OUT DX,AL		;SET HIGH AGAIN
LPSK01:	@P2
	RET
LPRINT	ENDP
SETLIN	PROC
	;AL=LINCUR POSITION ON 8 DIGIT DISPLAY
	@PSP
	@SE
	AND AL,07H
	@ES AL,LINCUR,0
	@PSO
	RET
SETLIN	ENDP
ADR20	PROC
	;GIVEN NO OF CX:DX FORM,IT FORMS 20 BIT NO IN CX,DX(LOWER WORD).
	PUSHF
	PUSH AX
	MOV AX,DX
	MOV DX,CX
	MOV CX,0000H
	@N SFCDX
	ADD DX,AX
	ADC CX,0000H
	AND CX,000FH		;SUPPRESS CARRY FORWARD
	POP AX
	POPF
	RET
ADR20   ENDP
ISRA0:	IRET			;DUMMY  
ISRA1:	IRET
ISRA2:	IRET
ISRA9	PROC
	;AH=02H--WR51,=01H--WARD,DL=ASCII CHR
	PUSHF
	CMP AH,02H
	JZ  WRITE51
	JMP NEAR PTR WARD
WRITE51:@P1
I69SK01:MOV AH,DL		;SAVE CHR
	MOV DX,9002H
I69LP01:IN AL,DX
	AND AL,81H		;CHECK DSR,TxRDY
	CMP AL,81H
	JNE I69LP01	
	MOV AL,AH
	MOV DX,9000H
	OUT DX,AL
	@P2
	@PU
	@SED
	JMP NEAR PTR W79LP02 
WARD:	PUSH DX
	PUSH AX
	MOV AH,08H
	INT 0A1H		;READ---->AL
	MOV DL,AL
	MOV AH,02H	
	INT 0A2H		;WRITE <---DL	
	POP AX
	MOV AL,DL		;RETURN THE CHR IN AL
	POP DX
	POPF
	IRET
ISRA9	ENDP
ISRA7   PROC 
	;AH=02--WR79,=01--WARD,DL=ASCII CHR
	;CHR (DL)WRITES INTO DISPLAY OF 8279,TACKLES CR,LF/ASCII CHRS 
	;CONVERTED INTO 7-SEG CODES,ASSUMES 8 BIT ASCII WITH D7=0
	PUSHF
	CMP AH,02H
	JZ WRITE79
	JMP NEAR PTR WARD
WRITE79:@PU
ONLYWR:	@SED
	AND DL,7FH
	CMP DL,20H
	JNC W79SK01		;CNT-CHR..NON PRINTABLES?
W79LP01:JMP NEAR PTR NONPRT
W79SK01:CMP DL,60H
	JC W79SK02
	JMP NEAR PTR NONPRT		;NON PRINTABLES
W79SK02:@M SI,TBLAS7S		;ASCII-->7 SEG
	@N LINSRH		;DL-----> AL
	JC W79LP01
	@N OUT7SEG
W79LP02:MOV AL,DL		;RESTORE CHR IN AL FOR LPRINT
	@EF DL,SPPRINT,0	;PRINTER ENABLED?
	CMP DL,"P"
	JNZ W79SK03
	@N LPRINT		;PRINT CHR IN AL-ASCII
W79SK03:@PO
	POPF
	IRET
NONPRT: CMP DL,LF
	JNZ W79SK04
	JMP NEAR PTR WR79LF
W79SK04:CMP DL,CR
	JNZ W79LP02
	XOR AL,AL		;CR
	@ES AL,LINCUR,0
	JMP NEAR PTR W79LP02
WR79LF: @EF DH,LINCUR,0		;LF
	XOR AL,AL
	@ES AL,LINCUR,0
	MOV CX,0008H
W79LP03:@N OUT7SEG
	LOOP W79LP03
	@ES DH,LINCUR,0
	JMP NEAR PTR W79LP02					
ISRA7   ENDP
ISRA8	PROC
	;AH=08--RD51/=0B---TEST51-->AL=FF IF CHR ELSE 00
	;AL-CHR
	PUSHF
	PUSH DX
	MOV DX,9002H
	CMP AH,08H
	JZ I68LP01	
	JMP NEAR PTR I68SK01		;TEST	
I68LP01:IN AL,DX
	MOV AH,AL		;SAVE STATUS FOR CALLING ROUTINE TO CHECK
	AND AL,02H
	JZ I68LP01
	MOV DX,9000H
	IN AL,DX
I68LP02:AND AH,38H		;SUPPRESS ALL EXCEPT 3 ERROR BITS
	POP DX
	POPF
	IRET
I68SK01:IN AL,DX		;TEST
	MOV AH,AL		;SAVE ERROR STATUS
	AND AL,02H
	JZ I68SK02		;NO CHR
	MOV AL,0FFH
	JMP NEAR PTR I68SK03
I68SK02:MOV AL,00H
I68SK03:JMP NEAR PTR I68LP02
ISRA8	ENDP
ISRA6	PROC 
	;AH=08H--->READ 8279,AH=0BH--->TEST STATUS OF KBD
	;AL=ASCII CHR AFTER READ///////AL=0FFH CHR EXISTS,ELSE 00H
	PUSHF
	PUSH DS
	PUSH ES
	PUSH DX
	@SED
	CMP AH,0BH
	JZ I66SK01		;TEST
	PUSH SI
I66LP01:@N KEYIN		;FETCH HEX CODE IN DL
	@M SI,TBLASX		;SMALL KBD
	@M SI,TBLASHX		;HEX-->ASCII,ASCII KBD
	@N LINSRH		;DL--->AL
	JC I66LP01
	POP SI
	JMP NEAR PTR I66END
I66SK01:PUSH AX
	MOV DX,9C03H
	IN AL,DX
	AND AL,0FH
	JZ I66SK02		;NO KEY 
	MOV DL,0FFH		;KEY EXISTS
	JMP NEAR PTR I66SK03
I66SK02:MOV DL,00H		;NO KEY
I66SK03:POP AX
	MOV AL,DL
I66END:	POP DX
	POP ES
	POP DS
	POPF
	IRET
ISRA6	ENDP
ISRAA	PROC
	;DELAY ROUTINE  EQU=CX*17+144 STATES
	@N DELAY
	IRET
ISRAA	ENDP
ISRAB	PROC
	;SENDS CR ONLY TO CONSOLE
	PUSH AX
	MOV AL,CR
	@N WR
	POP AX
	IRET
ISRAB	ENDP
ISRAC	PROC
	;CRLF
	@N CRLF
	IRET
ISRAC	ENDP
ISRAD	PROC
	@N NMIN
	@FAH
	IRET
ISRAD	ENDP
ISRAE	PROC
	@N NMOUT
	IRET
ISRAE	ENDP
ISRAF	PROC
	@N OUTMSG
	IRET
ISRAF	ENDP
ISRB0	PROC
	@N WRBYT
	IRET
ISRB0 	ENDP
ISRB1	PROC
	@N MOVIMD
	IRET
ISRB1	ENDP
ISRB2	PROC
	;PRINTER ENABLE [AL="p"]/DISABLE AL=X
	@N PRENDS
	IRET
ISRB2	ENDP
ISRB3	PROC
	;SETS SERIAL PAR CX=BAUD,AL=PARITY
	@N SETSR
	IRET
ISRB3	ENDP
ISRB4	PROC
	;PRINTS CHR IN AL
	@N LPRINT
	IRET
ISRB4	ENDP
ISRB5	PROC
	@N SETLIN
	IRET
ISRB5	ENDP
ISRB6	PROC
	@N BRANCH
	@FAH
	IRET
ISRB6	ENDP
ISRB7	PROC
	@N MULTMSG
	IRET
ISRB7	ENDP
ISRB8	PROC
	@N RDCRES
	@FAH
	IRET
ISRB8	ENDP
ISRB9	PROC
	@N RCVNO
	IRET
ISRB9	ENDP
ISRBA	PROC
	@N WR
	IRET
ISRBA	ENDP
ISRBB	PROC
	@N WRTENB
	IRET
ISRBB	ENDP
ISRBC	PROC
	@N WRTDSB
	IRET
ISRBC	ENDP
ISRBD	PROC
	@N DSPCOM
	IRET
ISRBD	ENDP
ISRBE	PROC
	;STORES AT INT NO IN AL,ADDR IN CX:SI
	@N STOINT
	IRET
ISRBE	ENDP
ISRBF	PROC
	;READ BYTE INTO AL FROM CX:SI
	@N RDBYT
	IRET
ISRBF	ENDP

ISR01:	PUSH ES			;MEANT FOR SSTP,BSTP
	PUSH AX
	@SE
	@EF AL,SPGSUB,0
	CMP AL,"B"		;BSTP?
	JNZ ISSK01
	JMP NEAR PTR ISSK02		;BSTP TREATMENT AFTER RGSAVE
ISSK01:	CMP AL,"S"		;SSTP?
	JNZ ISSK02		;==CF
	JMP NEAR PTR STEP
ISSK02:	POP AX			
	POP ES
	JMP NEAR PTR RGSAVE		;LIKE CF
STEP:	@EF AL,SPSTPC,0
	DEC AL			;DECR INTERNAL COUNT-SSTP
	@ES AL,SPSTPC,0		;
	JZ ISSK02
	POP AX
	POP ES
	IRET
ISRA5:	PUSH ES			;SERVES LIKE CF IN 8085
	PUSH AX
	XOR AX,AX
	@SE	
	@ES AL,SPGSUB,0
	@ES AL,SPBSTP,0		;RESETS SSTP/BSTP LOCn
	POP AX
	POP ES
ISR03:	;ISR FOR BSTEP
RGSAVE:	;SAVES ALL REGISTERS AND RETURNS DEPENDING
	;UPON SSTP/BSTP/CF ETC
	@PUA			;ALREADY FX,CS,IP ON STACK
	PUSH DS			;NOW SP,BP,AX,CX,DX,BX,SI,DI
	PUSH ES			;NOW DS,ES,SS =14
	PUSH SS
	MOV BP,SP
	@SED			;SETS ES ,DS ONLY
	@SS SPRGXX,0,1AH	;SS
	@SS SPRGXX,2,18H	;ES	
	@SS SPRGXX,4,16H	;DS
	@SS SPRGXX,6,0CH	;DI
	@SS SPRGXX,8,0AH	;SI
	@SS SPRGXX,10,02H	;BX
	@SS SPRGXX,12,06H	;DX
	@SS SPRGXX,14,04H	;CX
	@SS SPRGXX,16,00H	;AX
	@SS SPRGXX,18,0EH	;BP
	@SS SPRGXX,20,10H	;SP
	@SS SPRGXX,22,12H	;IP
	@SS SPRGXX,24,14H	;CS
	@SS SPRGXX,26,08H	;FX
	@EF AX,SPRGXX,08H	;FETCH FX
	AND AX,0FEFFH		;RESET TF
	@ES AX,SPRGXX,08H	;SAVE  
	@EF AX,SPRGXX,10H	;FETCH SP
	ADD AX,0006H		;INCREMENT SP SAVED SO AS THAT FX,CS,IP PUSHES
	@ES AX,SPRGXX,10H	;SAVE BACK
				;POPPING NOT REQUIRED SINCE REGS/SEG SET AUTO
				;MATICALLY	
	@EF AL,SPGSUB,0
	CMP AL,"S"		;IS IT STEP FUN?
	JNZ RGSK01		;MAY BE SSTP WITHIN BSTP
	JMP NEAR PTR RGSK	;CHECK IT
RGSK01:	CMP AL,"B"		;BSTP?
	JZ RGSK			;YES
	MOV AL,NULL		;LIKE CF AT 8085
	@ES AL,SPGSUB,0
	@ES AL,SPBSTP,0
RGSK:	JMP NEAR PTR CMDMOD		;RESET ALL BSTP/STEP FLAGS
ISRA3:	NOP		
CMDMOD:	NOP			;SYSTEM COMMANDS
	@RS			;RESTORE ALL SEG
	@N CRLF			;FOR SAFETY
	@M BX,MGCMD		;DISPLAY 'COMMAND='
	@N OUTMSG
	EVEN
CMDWDP  LABEL NEAR		;WITHOUT DESTROYING DISPLAY
ISRA4:	NOP
	@RS			;RESTORE ALL SEG ,ES<---0000

EXIT:	MOV	AH,4CH 			;RETURN TO DOS FUNCTION CALL
	INT	21H			;RETURN TO DOS
					; (VERSION 2.00 OR LATER)



